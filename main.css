.analytics-token-container {
  max-height: 180px;
  overflow-y: auto;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  padding: 6px;
  background: #fafafa;
}

.analytics-token {
  display: inline-block;
  margin: 2px;
  padding: 4px 8px;
  border-radius: 999px;
  background-color: #e0e7ff;
  cursor: pointer;
  user-select: none;
  font-size: 0.8rem;
}

.analytics-token.bg-primary {
  background-color: #0d6efd !important;
}
.analytics-token.text-white {
  color: #fff !important;
}







@bp.post("/api/analytics/psns_for_vehicle")
def analytics_psns_for_vehicle():
    """
    Given algo_name and vehicle, use cached dataframe to compute distinct psn values.
    """
    data = request.get_json(silent=True) or {}
    algo_name = data.get("algo_name")
    vehicle = data.get("vehicle")

    if not algo_name or not vehicle:
        return jsonify({"status": "error", "message": "algo_name and vehicle are required"}), 400

    df = ANALYTICS_DF_CACHE.get(algo_name)
    if df is None:
        return jsonify({
            "status": "error",
            "message": "No cached dataframe for this algorithm. Please reload parameters."
        }), 400

    try:
        df_vehicle = df[df["vehicle"] == vehicle]
        psns = sorted(df_vehicle["psn"].dropna().unique().tolist())
        return jsonify({"status": "ok", "psns": psns})
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500





@bp.post("/api/analytics/data")
def analytics_data():
    """
    Use cached dataframe from ANALYTICS_DF_CACHE (built by analytics_params_for_algo).
    Filter by vehicle, psn, and selected pnames (one or many).
    Return series grouped by pname for multi-line Plotly chart.
    """
    data = request.get_json(silent=True) or {}
    algo_name = data.get("algo_name")
    vehicle = data.get("vehicle")
    psn = data.get("psn")
    pnames = data.get("pnames")

    # Normalize pnames to a list
    if isinstance(pnames, str):
        pnames = [pnames]
    if not isinstance(pnames, list) or not pnames:
        return jsonify({"status": "error", "message": "At least one pname must be selected"}), 400

    if not algo_name or not vehicle or not psn:
        return jsonify({
            "status": "error",
            "message": "algo_name, vehicle, and psn are required"
        }), 400

    df = ANALYTICS_DF_CACHE.get(algo_name)
    if df is None:
        return jsonify({
            "status": "error",
            "message": "No cached dataframe for this algorithm. Please re-load parameters."
        }), 400

    try:
        # Filter dataframe
        df_filtered = df[
            (df["vehicle"] == vehicle) &
            (df["psn"] == psn) &
            (df["pname"].isin(pnames))
        ]

        # Group by pname, sort by date
        series_map = {}
        for pname in pnames:
            df_p = df_filtered[df_filtered["pname"] == pname].sort_values("date")
            if df_p.empty:
                continue
            series_map[pname] = [
                {"date": str(row["date"]), "pvalue": float(row["pvalue"])}
                for _, row in df_p.iterrows()
            ]

        return jsonify({
            "status": "ok",
            "algo_name": algo_name,
            "vehicle": vehicle,
            "psn": psn,
            "pnames": pnames,
            "series": series_map
        })
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500








  // ---------- Analytics logic (dataframe + dependent psn) ----------

  const algoListEl        = document.getElementById("analytics-algo-list");
  const selectedAlgoEl    = document.getElementById("analytics-selected-algo");
  const loadParamsBtn     = document.getElementById("analytics-load-params-btn");

  const selectPname       = document.getElementById("analytics-select-pname");
  const selectVehicle     = document.getElementById("analytics-select-vehicle");
  const selectPsn         = document.getElementById("analytics-select-psn");

  const analyticsPlotBtn  = document.getElementById("analytics-plot-btn");
  const analyticsStatusEl = document.getElementById("analytics-status");
  const analyticsPlotDiv  = document.getElementById("analytics-plot");

  let analyticsSelectedAlgo = null;

  function makeToken(value) {
    const span = document.createElement("span");
    span.className = "analytics-token";
    span.textContent = value;
    span.addEventListener("click", () => {
      analyticsSelectedAlgo = value;
      if (selectedAlgoEl) selectedAlgoEl.textContent = value;
      document.querySelectorAll("#analytics-algo-list .analytics-token").forEach(tok => {
        tok.classList.remove("bg-primary", "text-white");
      });
      span.classList.add("bg-primary", "text-white");
    });
    return span;
  }

  function fillTokenContainer(container, values) {
    container.textContent = "";
    if (!values || !values.length) {
      container.textContent = "(no values)";
      return;
    }
    values.forEach(v => {
      const tok = makeToken(v);
      container.appendChild(tok);
    });
  }

  function fillSelect(selectEl, values, {allowEmptyOption = true, multi = false} = {}) {
    if (!selectEl) return;
    selectEl.innerHTML = "";
    if (allowEmptyOption && !multi) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "-- select --";
      selectEl.appendChild(opt);
    }
    if (!values || !values.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "(no values)";
      selectEl.appendChild(opt);
      return;
    }
    values.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = v;
      selectEl.appendChild(opt);
    });
    if (!multi && selectEl.options.length > 1) {
      selectEl.selectedIndex = 1;
    }
  }

  // Step 1: load algorithms
  async function loadAlgorithms() {
    if (!algoListEl) return;
    try {
      const res = await fetch("/api/analytics/algos");
      const data = await res.json();
      if (data.status !== "ok") {
        algoListEl.textContent = data.message || "Error loading algorithms";
        return;
      }
      fillTokenContainer(algoListEl, data.algos || []);
    } catch (e) {
      algoListEl.textContent = "Network error loading algorithms: " + e;
    }
  }

  // Step 2: after algo selected + Submit, load pname & vehicle lists (uses cached df on server)
  loadParamsBtn?.addEventListener("click", async () => {
    if (!analyticsSelectedAlgo) {
      analyticsStatusEl.textContent = " Please select an algorithm first.";
      return;
    }
    analyticsStatusEl.textContent = " Loading parameters for " + analyticsSelectedAlgo + "...";

    try {
      const res = await fetch("/api/analytics/params_for_algo", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ algo_name: analyticsSelectedAlgo })
      });
      const data = await res.json();
      if (data.status !== "ok") {
        analyticsStatusEl.textContent = data.message || "Error loading parameters";
        return;
      }

      fillSelect(selectPname,   data.pnames   || [], {allowEmptyOption: false, multi: true});
      fillSelect(selectVehicle, data.vehicles || [], {allowEmptyOption: true,  multi: false});
      fillSelect(selectPsn,     [],                {allowEmptyOption: true,  multi: false});

      analyticsStatusEl.textContent = " Parameters loaded. Select vehicle to see psn options.";
    } catch (e) {
      analyticsStatusEl.textContent = " Network error loading parameters: " + e;
    }
  });

  // Step 2b: when vehicle changes, load psns for that vehicle from cached dataframe
  selectVehicle?.addEventListener("change", async () => {
    if (!analyticsSelectedAlgo) return;
    if (!selectVehicle.value) {
      fillSelect(selectPsn, [], {allowEmptyOption: true, multi: false});
      return;
    }
    analyticsStatusEl.textContent = " Loading psn for vehicle " + selectVehicle.value + "...";
    try {
      const res = await fetch("/api/analytics/psns_for_vehicle", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          algo_name: analyticsSelectedAlgo,
          vehicle: selectVehicle.value
        })
      });
      const data = await res.json();
      if (data.status !== "ok") {
        analyticsStatusEl.textContent = data.message || "Error loading psns";
        return;
      }
      fillSelect(selectPsn, data.psns || [], {allowEmptyOption: true, multi: false});
      analyticsStatusEl.textContent = " Select pname(s), vehicle, psn and click Submit.";
    } catch (e) {
      analyticsStatusEl.textContent = " Network error loading psns: " + e;
    }
  });

  // Step 3: final Submit â€“ send selected pnames, vehicle, psn to analytics_data
  analyticsPlotBtn?.addEventListener("click", async () => {
    if (!analyticsSelectedAlgo) {
      analyticsStatusEl.textContent = " Please select an algorithm first.";
      return;
    }
    if (!selectPname || !selectVehicle || !selectPsn) {
      analyticsStatusEl.textContent = " Internal error: dropdowns not found.";
      return;
    }

    const selectedPnames = Array.from(selectPname.options)
      .filter(opt => opt.selected)
      .map(opt => opt.value)
      .filter(Boolean);

    const vehicle = selectVehicle.value || "";
    const psn     = selectPsn.value || "";

    if (!vehicle || !psn || !selectedPnames.length) {
      analyticsStatusEl.textContent = " Please select at least one pname, and choose vehicle and psn.";
      return;
    }

    analyticsStatusEl.textContent = " Loading data...";

    try {
      const res = await fetch("/api/analytics/data", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          algo_name: analyticsSelectedAlgo,
          vehicle,
          psn,
          pnames: selectedPnames
        })
      });
      const data = await res.json();
      if (data.status !== "ok") {
        analyticsStatusEl.textContent = data.message || "Error loading data";
        return;
      }

      const series = data.series || {};  // {pname: [ {date, pvalue}, ...], ...}
      const traces = [];

      Object.keys(series).forEach(pnameKey => {
        const pts = series[pnameKey] || [];
        const x = pts.map(p => p.date);
        const y = pts.map(p => p.pvalue);
        traces.push({
          x,
          y,
          mode: "markers+lines",
          type: "scatter",
          name: pnameKey
        });
      });

      const layout = {
        margin: { t: 20, r: 10, b: 50, l: 60 },
        xaxis: { title: "date" },
        yaxis: { title: "pvalue" }
      };

      Plotly.newPlot(analyticsPlotDiv, traces, layout);
      analyticsStatusEl.textContent = ` Loaded ${traces.reduce((sum, t) => sum + t.x.length, 0)} points across ${traces.length} pname series.`;
    } catch (e) {
      analyticsStatusEl.textContent = " Network error: " + e;
    }
  });

  // Initial load
  loadAlgorithms();
